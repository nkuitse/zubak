#!/bin/zsh

# Copyright 2016 Paul Hoffman <nkuitse@nkuitse.com>
# GNU General Public License, version 3 or greater (see COPYING)

typeset PROG=$0
typeset NAME=$0:t
typeset VERSION=0.02
typeset YEARS=2016
typeset AUTHOR='Paul Hoffman'
typeset EMAIL=nkuitse@nkuitse.com

typeset root=${ZUBAK_ROOT:=/var/local/backup}
typeset now

path=( /usr/local/libexec/zubak $root/bin $path )

main() {
    (( $# > 0 )) || set null
    typeset cmd=$1; shift
    egrep -q "^cmd_$cmd()" $PROG || usage
    cmd_$cmd "$@"
}

# Commands

cmd_nt() {
    #@ nt TARGET :: create a new target
    (( $# == 1 )) || usage nt
    typeset t=$1; shift
    tdir=$(targdir $t)
    [[ ! -d $tdir ]] || fatal "Target already exists: $t"
    mkdir -p $tdir/0/@empty
    mkdir -p $tdir/series
    ln -s 0 $(serdir $tdir current)
    print $(now) target $t created >> $(targlog)
    print $t >> $(targlist)
}

cmd_lt() {
    #@ lt :: list targets
    cat $(targlist)
}

cmd_ls() {
    #@ ls TARGET :: list series within a target
    (( $# == 1 )) || usage ls
    cat $(serlist $(targdir $1))
    ### awk '/^[0-9]+ series [^ ]+ open/ {print $3}' $(serlog $(targdir $1))
}

cmd_lb() {
    #@ lb TARGET [SERIES] :: list backups within a target (default: current series)
    typeset t=$1; shift
    typeset tdir=$(targdir $t)
    cd $tdir
    typeset s=${1:-$(current-series $tdir)}
    typeset sdir=$(serdir $tdir $s)
    typeset -a backups
    backups=( $(backups-in-series $sdir) )
    (( $#backups == 0 )) || print -l $backups
}

cmd_ns() {
    #@ ns TARGET :: create a new series
    (( $# == 1 )) || usage ns
    cd $(targdir $1); shift
    typeset tdir=$PWD
    typeset scur=$(current-series $tdir)
    [[ $scur == [0-9]* ]] || fatal "Unrecognized series: $scur"
    integer snew=$(( scur + 1 ))
    typeset snewdir=$(serdir $tdir $snew)
    typeset scurdir=$(serdir $tdir $scur)
    mkdir -p $snewdir
    mv $scurdir/@* $snewdir/@empty
    typeset now=$(now)
    {
        if (( scur == 0 )); then
            rmdir $scurdir
        else
            print $now series $scur close
        fi
        print $now series $snew open
    } >> $(serlog $tdir)
    print $snew >> $(serlist $tdir)
    typeset symlink=$(serdir $tdir current)
    rm -f $symlink
    ln -s $snew $symlink
    touch $snewdir/full.eum $snewdir/incr.eum
}

cmd_up() {
    #@ up TARGET [-n] [-f|-i|-d] :: perform a backup
    typeset opt dryrun=false mode=incr
    typeset -a zgopts
    while getopts :nfid opt; do
        case $opt in
            (n) dryrun=true
                zgopts+=( -n );;
            (f) mode=full ;;
            (i) mode=incr ;;
            (d) mode=diff ;;
            (*) usage up ;;
        esac
    done
    shift $(( OPTIND - 1 ))
    (( $# == 1 )) || usage up
    typeset t=$1; shift
    typeset tdir=$(targdir $t) now=$(now)
    path=( $tdir/bin.$(uname) $tdir/bin $path )
    typeset scur=$( current-series $tdir            )
    typeset sdir=$( serdir $tdir $scur              )
    typeset slog=$( serlog $tdir                    )
    typeset bkup=$( zubak-next-backup-id $now $tdir )

    cd $sdir
    if [[ $mode == full && -s full.eum ]]; then
        fatal "There is already a full backup in series $scur of target $t"
    fi

    if $dryrun; then
        print "DRY RUN : $now series $scur backup $bkup mode $mode begin"
        print "DRY RUN :" =zubak-find "|" =zubak-gather "$zgopts $mode"
        zubak-find | zubak-gather $zgopts $mode > /dev/null 2> >(sed 's/^/        > /')
        print "DRY RUN : $(now) series $scur backup $bkup mode $mode end"
        exit 0
    fi >&2

    # Start
    print $now series $scur backup $bkup mode $mode begin >> $slog
    print -l "begin $now" "target $PWD" "series $s" "backup $b" "mode $mode" >> $bkup.backup
    busy $sdir

    # Back up
    typeset hash offset size file
    zubak-find |
    zubak-gather $zgopts $mode 2> $bkup.eum |
    zubak-split $bkup |
    while read hash offset size file; do
        (( n++ < maxjobs )) || { wait; n=0 }
        zubak-compress $file &
        print "@$offset *$size #$hash $file"
    done >> $bkup.backup
    wait

    # Wrap up
    if [[ $mode != diff ]]; then
        grep '^[-+]' < $bkup.eum >> $mode.eum
        touch -d @$now $mode.eum
        [[ $mode != full ]] || cp full.eum incr.eum
    fi
    print -l "end $(now)" >> $bkup.backup
    touch -d @$now $bkup.backup
    idle $sdir
    zubak-archive $bkup.*
    print $(now) series $scur backup $bkup mode $mode end >> $slog
}

cmd_version() {
    #@ version [-v] :: print zubak version (-v and copyright information)
    if [[ $1 == -v ]]; then
        VERSION
        COPYRIGHT
        LICENSE
    else
        print $VERSION
    fi
}

cmd_help() {
    #@ help :: print help info
    print -l "usage: $NAME COMMAND [ARG...]" commands: >&2
    perl -ne '
        printf STDERR "    %-16s %s\n", $1, $2 if /^ +#@ (.+) :: (.+)/
    ' $PROG
}

cmd_null() {
    # No command was given
    cmd_help
    exit 1
}

# --- Utility functions

busy() {
    typeset sdir=$1
    mv $sdir/@idle $sdir/@busy  ||
    mv $sdir/@empty $sdir/@busy ||
    fatal "Can\'t set series $sdir:t to busy; may be in unknown state"
}

idle() {
    typeset sdir=$1
    mv $sdir/@busy $sdir/@idle ||
    fatal "Can\'t set series $sdir:t to idle"
}

targlist() {
    print $root/targets.list
}

targlog() {
    print $root/targets/targets.log
}

targdir() {
    print $root/targets/$1
}

serlist() {
    print $1/series.list
}

serlog() {
    print $1/series/series.log
}

serdir() {
    print $1/series/$2
}

backups-in-series() {
    typeset sdir=$1
    typeset -a backups
    backups=( $sdir/*.backup(.NOm) )
    (( $#backups == 0 )) || print -l $backups:t:r
}

latest-backup-in-series() {
    typeset sdir=$1
    typeset -a backups
    backups=( $(backups-in-series $sdir) )
    (( $#backups )) || return 0
    print ${backups[-1]}
}

current-series() {
    typeset tdir=$1
    typeset sdir=$(serdir $tdir current)
    [[ -h $sdir ]] || fatal "No current series in $tdir"
    readlink $sdir
}

now() {
    print -P '%D{%s}'
}

age-in-minutes() {
    typeset f=$1
    integer age=$(perl -e '($f, $now) = @ARGV; @s = stat($f); print("0\n"), exit 2 if !@s; print int(($now-$s[9])/60)' $f $now)
    (( $? == 0 )) || fatal "Can't stat $f"
    print $age
}

usage() {
    if (( $# == 1 )); then
        perl -ne "
            printf qq{usage: %s %s\n}, qq{$NAME}, \$1 if /#@ (${1[5,-1]} .+) :: (.+)/
        " $PROG
    else
        print "usage: $NAME COMMAND [ARG...]" >&2
        print "       $NAME help" >&2
    fi
    exit 1
}

fatal() {
    print -- "$@" >&2
    exit 2
}

VERSION() {
    print "This is $NAME version $VERSION" >&2
}

COPYRIGHT() {
    print "Copyright $YEARS $AUTHOR <$EMAIL>" >&2
}

LICENSE() {
    cat <<EOS >&2
GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
EOS
}

main "$@"
