#!/bin/zsh -e

typeset prog=$0
typeset root=${BAK_ROOT:=/var/local/backup}
typeset now=$(print -P '%D{%s}')

path+=( $root/bin )

main() {
    (( $# > 0 )) || set help
    typeset cmd=$1; shift
    egrep -q "^cmd_$cmd()" $prog || usage
    cmd_$cmd "$@"
}

cmd_nt() {
    #@ nt TARGET :: create a new target
    (( $# == 1 )) || usage $0:t
    typeset t=$1; shift
    [[ ! -d $root/targets/$t ]] || fatal "Target already exists: $t"
    mkdir -p $root/series/$t/0/@empty
    cd $root/targets
    typeset d=$target s=../series/$target
    while [[ $d != . ]]; do
        s=../$s
        d=$d:h
    done
    mkdir -p $t/conf
    ln -s $s $t/series
    ln -s 0 $t/series/current
    ${VISUAL:-${EDITOR:-vim}} $t/conf/sources
    # XXX What else?
}

cmd_ns() {
    #@ ns TARGET :: create a new series
    (( $# == 1 )) || usage $0:t
    cdtarg $1 series; shift
    typeset scur=$(readlink current)
    [[ $scur == [0-9]* ]] || fatal "Unrecognized series: $scur"
    integer snew=$(( scur + 1 ))
    mkdir -p $snew
    mv $scur/@* $snew/@empty
    {
        (( scur == 0 )) || print $now series $scur close
        print $now series $snew open
    } >> series.log
    rm -f current
    ln -s $snew current
}

cmd_up() {
    #@ up TARGET :: perform a backup
    (( $# == 1 )) || usage $0:t
    cdtarg $1; shift
    path+=( $PWD/bin.$(uname) $PWD/bin )
    cd series/current
    typeset -a bref
    typeset b=$(bakz-next-backup-id $now) key hash offset size file
    integer n=0 MAXN=10
    bref=( *.backup(.) )
    (( $#bref == 0 )) || bref=( ${${args[-1]}:r} )
    # Punt to the backup script (may or may not be target-specific)
    exec bakz-backup $b $now $bref
}

# --- Utility functions

cdtarg() {
    typeset t=$1; shift
    [[ -d $root/targets/$t/$* ]] || fatal "No such target: $t"
    cd $root/targets/$t/$*
}

usage() {
    if (( $# == 1 )); then
        perl -ne "
            printf qq{usage: %s %s\n}, qq{$prog:t}, \$1 if /#@ ($1 .+) :: (.+)/
        " $prog
    else
        print "usage: $prog:t CMD [ARG...]" >&2
        print "       $prog:t help" >&2
    fi
    exit 1
}

fatal() {
    print -- "$@" >&2
    exit 2
}

main "$@"
