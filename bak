#!/usr/bin/perl

use strict;
use warnings;

use IPC::Run qw(run);
use POSIX qw(strftime);
use Getopt::Long
    qw(:config posix_default gnu_compat require_order bundling no_ignore_case);

sub blather;
sub note;
sub usage;
sub fatal;

sub xchdir;
sub xsymlink;
sub xunlink;
sub xmkdir;
sub xopen;
sub xscript;
sub now;

my $root = '/var/local/backup';
my $now;
my ($verbose, $quiet);

xchdir $root;

usage if !@ARGV;
&{ __PACKAGE__->can('cmd_'.shift(@ARGV)) || usage };

sub cmd_ns {
    usage if @ARGV != 1;
    my ($t) = @ARGV;
    xchdir "targets/$t";
    my $target = read_target_conf($t);
    my @series = read_series_log($t);
    my @open = grep { ! $_->{'closed'} } @series;
    fatal "multiple open series: $t" if @open > 1;
    close_series($target, $open[0]) if @open;
    my $s = max(map { $_->{'series'} } @series) + 1;
    open_series($t, $s);
    print $s, "\n";
}

sub cmd_lt {
    xchdir 'targets';
    my @tconf = map { glob($_) } qw(*/target.conf */*/target.conf */*/*/target.conf);
    s{/target\.conf$}{} for @tconf;
    print $_, "\n" for @tconf;
}

sub cmd_ls {
    my $hdr;
    GetOptions(
        'h' => \$hdr,
    ) or usage;
    usage if !@ARGV;
    my $t = shift @ARGV;
    xchdir "targets/$t";
    my @series = read_series_log($t);
    @ARGV = map { $_->{'series'} } @series if !@ARGV;
    printf "%5s %8s %s\n", qw(nbkup nfiles target) if $hdr;
    foreach my $s (@ARGV) {
        my ($series) = map { $_->{'series'} eq $s ? ($_) : () } @series;
        next if !defined $series;
        my @b = @{ $series->{'backups'} || [] };
        printf "%5d %8d %s\n", scalar(@b), $s, $t;
    }
}

sub cmd_lb {
    my $hdr;
    GetOptions(
        'h' => \$hdr,
    ) or usage;
    usage if !@ARGV;
    my $t = shift @ARGV;
    xchdir "targets/$t";
    my @series = read_series_log($t);
    @ARGV = map { $_->{'series'} } @series if !@ARGV;
    printf "%9s %7s %3s %-16.16s %s\n", qw(nfiles size ser backup target) if $hdr;
    foreach my $s (@ARGV) {
        my ($series) = map { $_->{'series'} eq $s ? ($_) : () } @series;
        fatal "no such series: $s" if !defined $series;
        my @b = @{ $series->{'backups'} || [] };
        foreach my $backup (@b) {
            my $result = $backup->{'result'};
            my $b = $backup->{'backup'};
            %$backup = ( %$backup, %{ kvread("series/$s/$b.backup") } );
            printf "%9d %7s %3d %-16.16s %s\n", $backup->{'files'}, num2hum($backup->{'size'}), $s, $b, $t;
        }
    }
}

sub open_series {
    my ($t, $s) = @_;
    xunlink "$root/targets/$t/series/current" if -e "$root/targets/$t/series/current";
    xsymlink $s, "$root/targets/$t/series/current";
    xmkdir "$root/targets/$t/series/$s", "$root/targets/$t/series/$s/\@empty";
    printf { xopen('>>', "$root/targets/$t/series/series.log") } "%d series %s open\n", now, $s;
}

sub close_series {
    my ($target, $series) = @_;
    my $s = $series->{'series'};
    my $status = glob("series/$s/\@*");
    fatal "series has no status: $s" if !defined $status;
    fatal "series has error status: $s" if $status =~ m{.+/\@error$};
    rename $status, "series/$s/\@closed" or fatal "can't close series $s: $!";
}

sub max {
    my $n = 0;
    foreach (@_) {
        $n = $_ if $_ > $n;
    }
    return $n;
}

sub cmd_up {
    usage if @ARGV != 1;
    my ($t) = @ARGV;
    xchdir "targets/$t";
    my $target = read_target_conf($t);
    my @series = read_series_log($t);
    my @open = grep { ! $_->{'closed'} } @series;
    fatal "no open series: $t" if !@open;
    fatal "multiple open series: $t" if @open > 1;
    my $series = shift @open;
    my $backup = next_backup($target, $series);
    perform_backup($target, $series, $backup);
    printf STDERR
        "Backup %s complete: %d files (%sB) in %s\n",
        $backup->{'backup'},
        $backup->{'files'},
        num2hum($backup->{'size'}),
        sec2dur($backup->{'elapsed'}),
    ;
}

sub num2hum {
    my ($n) = @_;
    return sprintf('%.1fG', $n/2**30) if $n >= 2**30;
    return sprintf('%.1fM', $n/2**20) if $n >= 2**20;
    return sprintf('%.1fK', $n/2**10) if $n >= 2**10;
    return $n;
}

sub sec2dur {
    my ($s) = @_;
    my @dur;
    push(@dur, int($s/604800).'w'), $s %= 604800 if $s > 604800;
    push(@dur, int($s/ 86400).'d'), $s %=  86400 if $s >  86400;
    push(@dur, int($s/  3600).'h'), $s %=   3600 if $s >   3600;
    push(@dur, int($s/    60).'m'), $s %=     60 if $s >     60;
    return join(' ', @dur, $s.'s');
}

sub read_target_conf {
    my ($t) = @_;
    kvread("$root/targets/$t/target.conf");
}

sub read_series_log {
    my ($t) = @_;
    my $fh = xopen('<', "$root/targets/$t/series/series.log");
    my (@s, %s);
    while (<$fh>) {
        if (/^(\d+) series (\S+) open/) {
            push @s, $s{$2} = { 'series' => $2, 'opened' => $1 };
        }
        elsif (/^(\d+) series (\S+) close/) {
            $s{$2}{'closed'} = $1;
        }
        elsif (/^(\d+) series (\S+) backup (\S+) (ok|fail)/) {
            push @{ $s{$2}{'backups'} ||= [] }, {
                'backup' => $3,
                'result' => $4,
            };
        }
    }
    return @s;
}

sub perform_backup {
    my ($target, $series, $backup) = @_;
    my $b = $backup->{'backup'};
    my $s = $series->{'series'};
    my @gather = ('bin/gather');
    my $fhlog;
    my $ok = eval {
        if (rename "series/$s/\@idle", "series/$s/\@running") {
            my $l = last_backup($series) or die "no previous backup: $s";
            push @gather, "series/$s/all";
        }
        elsif (!rename "series/$s/\@empty", "series/$s/\@running") {
            die "backup series not in coherent state: $s";
        }
        $fhlog = xopen('>>', 'series/series.log');
        my $chunksize = $target->{'chunk-size'} || '64M';
        my @split  = ('split', '-b' => $chunksize, '-a' => 3, '-d', '-', "series/$s/$b.");
        if (run(\@gather, '2>', "series/$s/$b.eum", '|', \@split)) {
            printf $fhlog "%d series %d backup %s ok\n", now, $s, $b;
        }
        else {
            printf $fhlog "%d series %d backup %s fail %d\n", now, $s, $b, $?;
            rename "series/$s/\@running", "series/$s/\@error";
            fatal "Backup failed";
        }
        xchdir("series/$s");
        # Record backup details
        my $fh = xopen('<', "$b.eum");
        my $fhall = xopen('>>', 'all.eum');
        my $count = 0;
        while (<$fh>) {
            print $fhall $_;
            $count++, next if /^[+]/;
            $backup->{$1} = $2, next if /^\$(\S+)\s+(.*)/;
        }
        $backup->{'files'} = $count;
        $backup->{'end'} ||= time;
        $backup->{'elapsed'} = $backup->{'end'} - $backup->{'begin'};
        kvwrite("$b.backup", $backup);
        my @b = glob("$b.*");
        if (run([qw(b2sum -a blake2b), @b], '>', ".$b.b2sum")) {
            rename ".$b.b2sum", "$b.b2sum";
        }
        else {
            unlink ".$b.b2sum";
            rename '@running', '@error'
                or fatal "Can't finish backup: $!";
            fatal "can't checksum output: $!";
        }
        # Archive data files if applicable
        xscript "$root/targets/$target/bin/archive", $b;
        rename '@running', '@idle'
            or fatal "Can't finish backup: $!";
        1;
    };
    if (!$ok) {
        my @b = glob("$b.*");
    }
}

sub next_backup {
    my ($target, $series) = @_;
    return {
        'backup' => timestamp($target->{'timestamp-format'}),
    }
}

sub last_backup {
    my ($series) = @_;
    my @backups = grep { $_->{'result'} eq 'ok' } @{ $series->{'backups'} };
    return if !@backups;
    return $backups[-1]{'backup'};
}

sub timestamp {
    my ($fmt, $t) = @_;
    $fmt //= '%Y%m%dT%H%M%SZ';
    $t //= now;
    return strftime($fmt, gmtime $t);
}

sub xchdir {
    my ($path) = @_;
    blather "chdir $path";
    chdir $path or fatal "Can't chdir $path: $!";
}

sub fatal {
    print STDERR "\e[31;1m", @_, "\e[0m\n";
    exit 2;
}

sub blather {
    return if !$verbose;
    print STDERR @_, "\n";
}

sub note {
    print STDERR "\e[32;1m", @_, "\e[0m\n" if !$quiet;
}

sub kvread {
    my ($f) = @_;
    my %h;
    my $fh = xopen($f);
    while (<$fh>) {
        chomp;
        next if /^\s*(?:#.*)?$/;  # Skip blank lines and comments
        $h{$1} = $2, next if /^(\S+)\s+(.*)$/;
        fatal "Invalid line in $f: $_";
    }
    close $fh;
    return \%h;
}

sub kvwrite {
    my ($f, $h) = @_;
    my $fh = xopen('>', $f);
    foreach (sort keys %$h) {
        print $fh $_, ' ', $h->{$_}, "\n";
    }
}

sub xopen {
    blather("open @_");
    my $f = pop;
    my $m = @_ ? shift : '<';
    open my $fh, $m, $f or fatal "Can't open $f: $!";
    return $fh;
}

sub xsystem {
    blather("system @_");
    my $ok = run @_;
    return if $ok;
    my $prog = shift;
    fatal "$prog: fatal [ @_ ] $!";
}

sub xscript {
    my $script = shift;
    return if ! -x $script || ! -f _;
    xsystem $script, @_;
}

sub xunlink {
    blather("unlink @_");
    unlink($_) or fatal "Can't unlink $_: $!" for @_;
}

sub xsymlink {
    my ($o, $n) = @_;
    blather("symlink $n -> $o");
    symlink $o, $n or fatal "Can't create symlink $n -> $o: $!";
}

sub xmkdir {
    foreach (@_) {
        next if -d;
        blather("mkdir $_");
        mkdir $_ or fatal "Can't mkdir $_: $!";
    }
}

sub now {
    $now //= time;
}

